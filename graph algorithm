// T.C = O(n^2)   adjacency matrix
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m;

     //declare the adjacency matrix for graph
    //as graph has one based indexing so you have to take the matrix of size 1 greater
    //if 0 based indexing, matrix size = mat[m][n]
    //if 1 based indexing, matrix size = mat[m+1][n+1]
    int mat[n+1][m+1];
    for(int i=0;i<m;i++){   
        int u,v;
        cin>>u>>v;
        mat[u][v] = 1;
        mat[v][u] = 1;
    }
    return 0;
}

// Adjacency list
// 0 based indexing
#include<bits/stdc++.h>
using namespace std;

int main(){
    // n = no of vertices
    // m = no of edges
    int n,m;
    cin>>n>>m;

    //size will be n as graph is 0 based indexing in our case.
    vector<int> adj[n];

    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        //if the graph is undirected then onmit the next line
        adj[v].push_back(i);
    }
    return 0;
}

// 0 based indexing
#include<bits/stdc++.h>
using namespace std;

int main(){
    // n = no of vertices
    // m = no of edges
    int n,m;
    cin>>n>>m;

    //size will be n as graph is 0 based indexing in our case.
    vector<int> adj[n];

    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        //if the graph is undirected then onmit the next line
        adj[v].push_back(i);
    }
    return 0;
}

// 1 based indexing
#include<bits/stdc++.h>
using namespace std;

int main(){
    // n = no of vertices
    // m = no of edges
    int n,m;
    cin>>n>>m;

    //size will be n as graph is 0 based indexing in our case.
    vector<int> adj[n+1];

    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        //if the graph is undirected then onmit the next line
        adj[v].push_back(i);
    }
    return 0;
}

// space complexity: O(N + 2E)

// weighted graph
#include<bits/stdc++.h>
using namespace std;

int main(){
    //n = no of vertices
    // m = no of edges
    int n,m;
    cin>>n>>m;

    //size will be n+1 as graph is based indexing in our case.
    // as graph is weighted so take pair
    vector<pair<int, int>> adj[n+1];

    for(int i=0;i<m;i++){
        int u, v, wt;
        cin>>u>>v>>wt;

        adj[u].push_back({v, wt});
        adj[v].push_back({u, wt});
    }
    return 0;
}
// space complexity: O(N+2E) + 2E

/*Time complexity
T.C would be O(N+E) where N is the time taken for visiting N nodes and E is for travelling through adjacent nodes overall.

Space Complexity
S.C would be O(N+E) + O(N) + O(N) where, O(N+E) for adjacency list, again O(N) for visited array and alst O(N) for storing the answer, i.e, the BFS array.*/

#include<bits/stdc++.h>
using namespace std;

void bfsHelper(int src, vector<int>&vis, vector<int>&bfs, vector<int> adj[]){
    queue<int> q;
    //push the first node in a queue
    q.push(src);
    //mark it as visited
    vis[src] = 1;
    //continue until queue will not become empty
    while(!q.empty()){
        //take the first node from queue
        int node = q.front();
        //delete it from queue
        q.pop();
        //push it in answer
        bfs.push_back(node);
        //traverse for all its adjacent node
        for(auto it : adj[node]){
            //if it is not visited then push it in a queue and mark it as visited
            if(!vis[it]){
                q.push(it);
                vis[it] = 1;
            }
        }
    }
}

vector<int> findBFS(int v, vector<int> adj[]){
    //create visited array to keep track of nodes whether they are visited or not so that they can't be traversed twice
    vector<int> vis(v,0);
    //bfs will contain the resultant bfs array
    vector<int> bfs;
    //do thge operation for all the components
    for(int i=0;i<v;i++){
        if(!vis[i]){
            bfsHelper(i,vis,bfs,adj);
        }
    }
    return bfs;
}

int main(){
    //n = no of vertices
    // m = no of edges
    int n, m;
    cin>>n>>m;
    //graph has 0 based indexing
    //create adjacency list.
    vector<int> adj[n];

    //take edges as input
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        //this is unidirected graph
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    //store ans print answer
    vector<int> ans = findBFS(n, adj);
    for(int i=0;i<n;i++){
        cout<<ans[i]<<" ";
    }
    return 0;
}

// 1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

void bfsHelper(int source, vector<int>&vis, vector<int>&bfsArr, vector<int>adj[]){
    queue<int>q;
    q.push(source);
    vis[source] = 1;

    while(!q.empty()){
        int node = q.front();
        bfsArr.push_back(node);
        q.pop();
        for(auto it : adj[node]){
            if(!vis[it]){
                q.push(it);
                vis[it] = 1;
            }
        }
    }
}

void bfs(int v, vector<int> adj[]){
    vector<int> vis(n+1, 0);
    vector<int> bfsArr;

    for(int i=1;i<v;i++){
        if(!vis[i])
        bfsHelper(i,vis,bfsArr,adj);
    }
    for(int i=0;i<bfsArr.size();i++){
        cout<<bfsArr[i]<<" ";
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int> adj[n+1];
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    bfs(n,adj);
    return 0;
}
//DFS
/*Time complexity and space complexity
Time complexity would be O(N+E), N is the time taken for visiting N nodes and E is for traveling through adjacent nodes overall
Space complexity would be O(N+E) + O(N) + O(N) same as BFS N+E for adjacency list, N for visited array and other N for auxiliary space.
*/
// 0 based Indexing
#include<bits/stdc++.h>
using namespace std;

void dfs(int node, vector<int> &vis, vector<int>&storeDFS, vecto<int> adj[]){
    storeDFS.push_back(node);
    vis[node] = 1;
    for(auto it : adj[node]){
        if(!vis[it]){
            dfs(it, vis, storeDFS, adj);
        }
    }
}

vector<int> findDFS(int v, vector<int> adj[]){
    vector<int> vis(v,0);
    vector<int> storeDFS;

    for(int i=0;i<v;i++){
        if(!vis[i]){
            dfs(i,vis,storeDFS,adj);
        }
    }
    return storeDFS;
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int>adj[n];
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<int> ans = findDFS(n, adj);
    for(int i=0;i<n;i++){
        cout<<ans[i]<<" ";
    }
    return 0;
}

// 1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

void dfsHelper(int node, vector<int>&vis, vector<int>&dfsArr, vector<int> adj[]){
    dfsArr.push_back(node);
    vis[node] = 1;

    for(auto it : adj[node]){
        if(!vis[it]){
            dfsHelper(it,vis,dfsArr,adj);
        }
    }
}

void dfs(int v, vector<int>adj[]){
    vector<int> vis(v+1, 0);
    vector<int> dfsArr;

    for(int i=0;i<v;i++){
        if(!vis[i])
        dfsHelper(i,vis,dfsArr,adj);
    }
    for(int i=0;i<dfsArr.size();i++){
        cout<<dfsArr[i]<<" ";
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int> adj[n+1];
    for(int i=0;i<n;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(n, adj);
    return 0;
}

// detect cycle-BFS
/*Time Complexity and Space complexity:
Time complexity would be same as DFS i,e O(N+E) N is time taken for visiting N nodes, and E is for traveling through adjacent nodes overall.
Space Complexity would be O(N+E) + O(N) + O(N) for adjacency list, visited array and queue. */

//0 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycleBFS(int src, vector<int>&vis, vector<int> adj[]){
    queue<pair<int, int>> q;
    vis[src] = 1;
    q.push({src, -1});

    while(!q.empty()){
        int node = q.front().first;
        int par = q.front().second;
        q.pop();

        for(auto it : adj[node]){
            if(!vis[it]){
                vis[it] = 1;
                q.push({it, node});
            }
            else if(it != par)
            return true;
        }
    }
    return false;
}

bool isCycle(int v, vector<int> adj[]){
    vector<int> vis(v,0);

    for(int i=0;i<v;i++){
        if(!vis[i]){
            if(checkCycleBFS(i, vis, adj))
            return true;
        }
    }
    return false;
}

int main(){
    int n,m;
    cin>>n>>m;

    vector<int> adj[n];
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(isCycle(n, adj))
    cout<<"Yes";
    else
    cout<<"No";
    return 0;
}

// 1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycleBfS(int src, vector<int> &vis, vector<int> adj[]){
    queue<pair<int, int>> q;
    vis[src] = 1;
    q.push({src, -1});

    while(!q.empty()){
        int node = q.front().first;
        int par = q.front().second;
        q.pop();

        for(auto it: adj[node]){
            if(!vis[it]){
                vis[it] = 1;
                q.push({it, node});
            }
            else if(it != par)
            return true;
        }
    }
    return false;
}

bool isCycle(int v, vector<int> adj[]){
    vector<int> vis(v+1, 0);

    for(int i=1;i<=v;i++){
        if(!vis[i]){
            if(checkCycleBFS(i, vis, adj))
            return true;
        }
    }
    return false;
}

int main(){
    int n,m;
    cin>>n>>m;

    vector<int> adj[n+1];
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(isCycle(n,adj))
    cout<<"Yes";
    else
    cout<<"No";
    return 0;
}

// detect cycle - dfs
/*Time complexity would be same as DFS i,e O(N+E) N is time taken for visiting N nodes, and E is for traveling through adjacent nodes overall.
Space Complexity would be O(N+E) + O(N) + O(N) for adjacency list, visited array and auxilliary space.*/

// 0 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycleDFS(int node, int par, vector<int> &vis, vector<int> adj[]){
    vis[node] = 1;
    for(auto it : adj[node]){
        if(!vis[it]){
            if(checkCycleDFS(it, node, vis, adj)) return true;
        }
        else if(it != par) return true;
    }
    return false;
}

bool isCycle(int v, vector<int> adj[]){
    vector<int> vis(v, 0);
    
    
    for(int i=0; i<v; i++){
        if(!vis[i]){
            if(checkCycleDFS(i, -1, vis, adj)) return true;
        }
    }
    return false;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(isCycle(n, adj)) cout<<"Yes";
    else cout<<"No";
    return 0;
}

// 1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycleDFS(int node, int par, vector<int> &vis, vector<int> adj[]){
    vis[node] = 1;
    for(auto it : adj[node]){
        if(!vis[it]){
            if(checkCycleDFS(it, node, vis, adj)) return true;
        }
        else if(it != par) return true;
    }
    return false;
}

bool isCycle(int v, vector<int> adj[]){
    vector<int> vis(v+1, 0);
    
    
    for(int i=1; i<=v; i++){
        if(!vis[i]){
            if(checkCycleDFS(i, -1, vis, adj)) return true;
        }
    }
    return false;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n+1];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(isCycle(n, adj)) cout<<"Yes";
    else cout<<"No";
    return 0;
}

//Check if Graph is Bipartite using BFS
/*
Time complexity and space complexity
Time complexity would be O(N+E)
Space complexity would be O(N+E) + O(N) + O(N) for adjacency list, queue, color array
*/

//0 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkBipartite(int src, int color[], vector<int> adj[]){
    queue<int> q;
    color[src] = 1;
    q.push(src);
    
    while(!q.empty()){
        int node = q.front();
        q.pop();
        for(auto it : adj[node]){
            if(color[it]==-1){
                color[it] = 1-color[node];
                q.push(it);
            }
            else if(color[it] == color[node]) return false;
        }
    }
    return true;
}

bool bipartite(int v, vector<int> adj[]){
    int color[v];
    memset(color, -1, sizeof color);

    for(int i=0;i<v;i++){
        if(color[i] == -1){
            if(!checkBipartite(i, color, adj))
            return false;
        }
    }
    return true;
}

int main(){
    int n,m;
    cin>>n>>m;
    
    vector<int> adj[n];
    for(int i=0;i<m;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(biparitite(n, adj))
    cout<<"Yes";
    else
    cout<<"No";
}

// 1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkBipartite(int src, int color[], vector<int> adj[]){
    queue<int> q;
    color[src] = 1;
    q.push(src);
    
    while(!q.empty()){
        int node = q.front();
        q.pop();
        for(auto it : adj[node]){
            if(color[it]==-1){
                color[it] = 1-color[node];
                q.push(it);
            }
            else if(color[it] == color[node]) return false;
        }
    }
    return true;
}

bool bipartite(int v, vector<int> adj[]){
    int color[v+1];
    memset(color, -1, sizeof color);
    
    for(int i=1; i<=v; i++){
        if(color[i] == -1){
            if(!checkBipartite(i, color, adj)) return false;
        }
    }
    
    return true;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n+1];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
        adj[v].push_back(u);
        
    }
    
    if(bipartite(n, adj)) cout<<"Yes";
    else cout<<"No";
    
    return 0;
}

// check biparite graph using dfs

#include<bits/stdc++.h>
using namespace std;

bool bipartite(int node, int color[], vector<int> adj[]){
    //if not colored then color the node, this will run just node of any component
    if(color[node] == -1)
    color[node] = 1;

    //traverse for all adjacent nodes
    for(auto it : adj[node]){
        //if not colored then color it and call recursion
        if(color[it] == -1){
            color[it] = 1-color[node];
            //if at any point recursion returns false then return false, no need to check further
            if(!bipartiteddfs(it,color,adj))
            return false;
        }
        //if node is already colored with the same color as parent then return false
        else if(color[it] == color[node])
        return false;
    }
    //if all condiion passes then return true
    return true;
}

bool bipartite(int v, vector<int>adj[]){
    int color[v];
    memset(color, -1 ,sizeof color);
    for(int i=0;i<v;i++){
        if(color[i] == -1){
            if(!bipartitedfs(i,color,adj))
            return false;
        }
    }
    return true;
}

int main(){
    int n,m;
    cin>>n>>m;

    vector<int> adj[n];
    for(int i=0;i<n;i++){
        int u,v;
        cin>>u>>v;

        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    if(bipartite(n, adj))
    cout<<"Yes";
    else
    cout<<"No";

    return 0;
}

//1 based Indexing
#include<bits/stdc++.h>
using namespace std;

bool bipartitedfs(int node, int color[], vector<int> adj[]){
    //if not colored then color the node, this will run just for the first node of any component
    if(color[node] == -1) color[node] = 1;
    
    //traverse for all adjacent nodes
    for(auto it : adj[node]){
        //if not colored then color it and call recursion
        if(color[it] == -1){
            color[it] = 1-color[node];
            //if at any point recursion returns false then return false, no need to check further
            if(!bipartitedfs(it, color, adj)) return false;
        }
        //if node is already colored with the same color as parent then return false
        else if(color[it] == color[node]) return false;
    }
    
    //if all condition passes then return true
    return true;
}

bool bipartite(int v, vector<int> adj[]){
    int color[v+1];
    memset(color, -1, sizeof color);
    for(int i=1; i<=v; i++){
        if(color[i] == -1){
            if(!bipartitedfs(i, color, adj)) return false;
        }
    }
    return true;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n+1];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    if(bipartite(n, adj)) cout<<"Yes";
    else cout<<"No";
    
    return 0;
}

/*
Detect cycle in directed graph
*/
Time complexity and space complexity
Time complexity would be O(N+E) due to simple DFS call
Space complexity would be O(N+E) + O(N) + O(N) + O(N) adjacency list, visited array, dfs visited and auxilliary space for dfs call
0 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycle(int node, int visited[], int dfsvisited[], vector<int> adj[]){
    visited[node] = 1;
    dfsvisited[node] = 1;
    
    for(auto it : adj[node]){
        if(!visited[it]){
            if(checkCycle(it, visited, dfsvisited, adj)) return true;
        }
        else if(dfsvisited[it]) return true;
    }
    dfsvisited[node]=0;
    return false;
}

bool cycle(int v, vector<int> adj[]){
    int visited[v];
    int dfsvisited[v];
    
    memset(visited, 0, sizeof visited);
    memset(dfsvisited, 0, sizeof dfsvisited);
    
    for(int i=0; i<v; i++){
        if(visited[i] == 0){
            if(checkCycle(i, visited, dfsvisited, adj)) return true;
        }
    }
    return false;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
    }
    if(cycle(n, adj)) cout<<"Yes";
    else cout<<"No";
    
    return 0;
}
1 Based Indexing
#include<bits/stdc++.h>
using namespace std;

bool checkCycle(int node, int visited[], int dfsvisited[], vector<int> adj[]){
    visited[node] = 1;
    dfsvisited[node] = 1;
    
    for(auto it : adj[node]){
        if(!visited[it]){
            if(checkCycle(it, visited, dfsvisited, adj)) return true;
        }
        else if(dfsvisited[it]) return true;
    }
    dfsvisited[node]=0;
    return false;
}

bool cycle(int v, vector<int> adj[]){
    int visited[v+1];
    int dfsvisited[v+1];
    
    memset(visited, 0, sizeof visited);
    memset(dfsvisited, 0, sizeof dfsvisited);
    
    for(int i=1; i<=v; i++){
        if(visited[i] == 0){
            if(checkCycle(i, visited, dfsvisited, adj)) return true;
        }
    }
    return false;
}

int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n+1];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
    }
    if(cycle(n, adj)) cout<<"Yes";
    else cout<<"No";
    
    return 0;
}





















































































































































































































































































































































































































